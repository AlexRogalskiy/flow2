{
  "$schema": "http://json-schema.org/draft-07/schema#",
  "title": "Catalog",
  "description": "Each catalog source defines a portion of a Flow Catalog, by defining collections, derivations, tests, and materializations of the Catalog. Catalog sources may reference and import other sources, in order to collections and other entities that source defines.",
  "type": "object",
  "properties": {
    "$schema": {
      "title": "JSON-Schema against which the Catalog is validated.",
      "default": null,
      "type": [
        "string",
        "null"
      ]
    },
    "collections": {
      "title": "Collections defined by this Catalog.",
      "default": [],
      "examples": [
        [
          {
            "derivation": null,
            "key": [
              "/json/ptr"
            ],
            "name": "a/collection",
            "projections": {},
            "schema": "../path/to/local.yaml"
          }
        ]
      ],
      "type": "array",
      "items": {
        "$ref": "#/definitions/Collection"
      }
    },
    "import": {
      "title": "Import other Flow catalog sources.",
      "description": "By importing another Flow catalog source, the collections, schemas, and derivations it defines become usable within this Catalog source. Each import is an absolute URI, or a URI which is relative to this source location.",
      "default": [],
      "examples": [
        [
          "../path/to/local.yaml",
          "https://example/resource"
        ]
      ],
      "type": "array",
      "items": {
        "$ref": "#/definitions/RelativeUrl"
      }
    },
    "materializations": {
      "title": "Materializations defined by this catalog.",
      "description": "Materializations project a view of the current state into an external system like a database or key/value store. These states will be kept up to date automatically as documents are processed in the collection. The keys used here are arbitrary identifiers that will be used to uniquely identify each materialization, and the values are any valid Materialization object.",
      "default": {},
      "type": "object",
      "additionalProperties": {
        "$ref": "#/definitions/Materialization"
      }
    },
    "nodeDependencies": {
      "title": "NPM package dependencies of the Catalog.",
      "description": "Dependencies are included when building the catalog's build NodeJS package, as {\"package-name\": \"version\"}. I.e. {\"moment\": \"^2.24\"}.\n\nVersion strings can take any form understood by NPM. See https://docs.npmjs.com/files/package.json#dependencies",
      "default": {
        "a-npm-package": "^1.2.3"
      },
      "type": "object",
      "additionalProperties": {
        "type": "string"
      }
    },
    "tests": {
      "title": "Tests defined by this Catalog.",
      "description": "Tests are keyed by their test name, and are defined in terms of a series of sequential test steps.",
      "default": {
        "Test that fob quips ipsum": []
      },
      "examples": [
        {
          "Test that fob quips ipsum": [
            {
              "ingest": {
                "collection": "a/collection",
                "documents": [
                  {
                    "example": "document"
                  },
                  {
                    "another": "document"
                  }
                ]
              }
            },
            {
              "verify": {
                "collection": "a/collection",
                "documents": [
                  {
                    "expected": "document"
                  }
                ],
                "partitions": null
              }
            }
          ]
        }
      ],
      "type": "object",
      "additionalProperties": {
        "type": "array",
        "items": {
          "$ref": "#/definitions/TestStep"
        }
      }
    }
  },
  "additionalProperties": false,
  "definitions": {
    "Collection": {
      "description": "Collection describes a set of related documents, where each adheres to a common schema and grouping key. Collections are append-only: once a document is added to a collection, it is never removed. However, it may be replaced or updated (either in whole, or in part) by a future document sharing its key. Each new document of a given key is \"reduced\" into existing documents of the key. By default, this reduction is achieved by completely replacing the previous document, but much richer reduction behaviors can be specified through the use of annotated reduction strategies of the collection schema.",
      "examples": [
        {
          "derivation": null,
          "key": [
            "/json/ptr"
          ],
          "name": "a/collection",
          "projections": {},
          "schema": "../path/to/local.yaml"
        }
      ],
      "type": "object",
      "required": [
        "key",
        "name",
        "schema"
      ],
      "properties": {
        "derivation": {
          "title": "Derivation which builds this collection from others.",
          "anyOf": [
            {
              "$ref": "#/definitions/Derivation"
            },
            {
              "type": "null"
            }
          ]
        },
        "key": {
          "title": "Composite key of this collection.",
          "allOf": [
            {
              "$ref": "#/definitions/CompositeKey"
            }
          ]
        },
        "name": {
          "title": "Canonical name of this collection.",
          "allOf": [
            {
              "$ref": "#/definitions/CollectionName"
            }
          ]
        },
        "projections": {
          "title": "Projections and logical partitions of this collection.",
          "default": {
            "a_field": "/json/ptr",
            "a_partition": {
              "location": "/json/ptr",
              "partition": true
            }
          },
          "allOf": [
            {
              "$ref": "#/definitions/Projections"
            }
          ]
        },
        "schema": {
          "title": "Schema against which collection documents are validated and reduced.",
          "examples": [
            "../path/to/schema#/$defs/subPath"
          ],
          "allOf": [
            {
              "$ref": "#/definitions/Schema"
            }
          ]
        }
      },
      "additionalProperties": false
    },
    "CollectionName": {
      "description": "Names consist of Unicode letters, numbers, and symbols: - _ . /\n\nSpaces and other special characters are disallowed.",
      "examples": [
        "a/collection"
      ],
      "type": "string",
      "pattern": "^[^ \t\n\\!@#$%^&*()+=\\<\\>?;:'\"\\[\\]\\|~`]+$"
    },
    "CompositeKey": {
      "description": "Ordered JSON-Pointers which define how a composite key may be extracted from a collection document.",
      "examples": [
        [
          "/json/ptr"
        ]
      ],
      "type": "array",
      "items": {
        "$ref": "#/definitions/JsonPointer"
      }
    },
    "Derivation": {
      "description": "A derivation specifies how a collection is derived from other collections. A collection without a derivation is a \"captured\" collection, into which documents are directly ingested.",
      "examples": [
        {
          "bootstrap": [],
          "register": {
            "initial": null,
            "schema": true
          },
          "transform": {
            "nameOfTransform": {
              "publish": {
                "nodeJS": "return doPublish(source, register);"
              },
              "readDelay": null,
              "shuffle": null,
              "source": {
                "name": "a/collection",
                "partitions": null,
                "schema": null
              },
              "update": {
                "nodeJS": "return doUpdate(source);"
              }
            }
          }
        }
      ],
      "type": "object",
      "properties": {
        "bootstrap": {
          "title": "Bootstrap lambdas of this derivation.",
          "default": [],
          "type": "array",
          "items": {
            "$ref": "#/definitions/Lambda"
          }
        },
        "register": {
          "title": "Register configuration of this derivation.",
          "default": {
            "initial": null,
            "schema": true
          },
          "allOf": [
            {
              "$ref": "#/definitions/Register"
            }
          ]
        },
        "transform": {
          "title": "Transforms which make up this derivation.",
          "default": {
            "nameOfTransform": {
              "source": {
                "name": "a/source/collection"
              }
            }
          },
          "type": "object",
          "additionalProperties": {
            "$ref": "#/definitions/Transform"
          }
        }
      },
      "additionalProperties": false
    },
    "FullProjection": {
      "description": "A full projection description which may specify a logical partition.",
      "examples": [
        {
          "location": "/json/ptr",
          "partition": true
        }
      ],
      "type": "object",
      "required": [
        "location"
      ],
      "properties": {
        "location": {
          "title": "Location of this projection.",
          "allOf": [
            {
              "$ref": "#/definitions/JsonPointer"
            }
          ]
        },
        "partition": {
          "title": "Is this projection a logical partition?",
          "default": false,
          "type": "boolean"
        }
      },
      "additionalProperties": false
    },
    "JsonPointer": {
      "description": "JSON Pointer which identifies a location in a document.",
      "examples": [
        "/json/ptr"
      ],
      "type": "string",
      "pattern": "/.+"
    },
    "Lambda": {
      "description": "Lambdas are user functions which are invoked by the Flow runtime to process and transform source collection documents into derived collections. Flow supports multiple lambda run-times, with a current focus on TypeScript and remote HTTP APIs.\n\nTypeScript lambdas are invoked within on-demand run-times, which are automatically started and scaled by Flow's task distribution in order to best co-locate data and processing, as well as to manage fail-over.\n\nRemote lambdas may be called from many Flow tasks, and are up to the API provider to provision and scale.\n\n(Note that Sqlite lambdas are not implemented yet).\n\nLambdas are invoked from a few contexts:\n\n\"Bootstrap\" lambdas are run once, at the start of a Flow task assignment, and before it processes any source documents. They provide an opportunity to initialize temporary state or ephemeral caches.\n\n\"Update\" lambdas take a source document and transform it into one or more register updates, which are then reduced into the associated register by the runtime. For example these register updates might update counters, or update the state of a \"join\" window.\n\n\"Publish\" lambdas take a source document, a current register and (if there is also an \"update\" lambda) a previous register, and transform them into one or more documents to be published into a derived collection.",
      "examples": [
        {
          "nodeJS": "return doPublish(source, register);"
        },
        {
          "nodeJS": "return doUpdate(source);"
        },
        {
          "nodeJS": "console.error('example of a bootstrap');"
        },
        {
          "remote": "http://example/api"
        }
      ],
      "anyOf": [
        {
          "type": "object",
          "required": [
            "nodeJS"
          ],
          "properties": {
            "nodeJS": {
              "type": "string"
            }
          }
        },
        {
          "type": "object",
          "required": [
            "sqlite"
          ],
          "properties": {
            "sqlite": {
              "type": "string"
            }
          }
        },
        {
          "type": "object",
          "required": [
            "sqliteFile"
          ],
          "properties": {
            "sqliteFile": {
              "$ref": "#/definitions/RelativeUrl"
            }
          }
        },
        {
          "type": "object",
          "required": [
            "remote"
          ],
          "properties": {
            "remote": {
              "type": "string"
            }
          }
        }
      ]
    },
    "Materialization": {
      "description": "A materialization represents the desire to maintain a continuously updated state of the documents in a collection.",
      "type": "object",
      "anyOf": [
        {
          "type": "object",
          "required": [
            "postgres"
          ],
          "properties": {
            "postgres": {
              "$ref": "#/definitions/SqlTargetConnection"
            }
          }
        },
        {
          "type": "object",
          "required": [
            "sqlite"
          ],
          "properties": {
            "sqlite": {
              "$ref": "#/definitions/SqlTargetConnection"
            }
          }
        }
      ],
      "required": [
        "collection"
      ],
      "properties": {
        "collection": {
          "description": "The name of the collection to materialize. This must exactly match the name of a collection that exists in either in this catalog, or in another catalog imported by this one.",
          "allOf": [
            {
              "$ref": "#/definitions/CollectionName"
            }
          ]
        }
      }
    },
    "PartitionSelector": {
      "description": "Partition selectors identify a desired subset of the available logical partitions of a collection.",
      "examples": [
        {
          "exclude": {
            "other_partition": [
              32,
              64
            ]
          },
          "include": {
            "a_partition": [
              "A",
              "B"
            ]
          }
        }
      ],
      "type": "object",
      "properties": {
        "exclude": {
          "description": "Partition field names and values which are excluded from the source collection. Any documents matching *any one* of the partition values will be excluded.",
          "default": {},
          "type": "object",
          "additionalProperties": {
            "type": "array",
            "items": true
          }
        },
        "include": {
          "description": "Partition field names and corresponding values which must be matched from the Source collection. Only documents having one of the specified values across all specified partition names will be matched. For example, source: [App, Web] region: [APAC] would mean only documents of 'App' or 'Web' source and also occurring in the 'APAC' region will be processed.",
          "default": {},
          "type": "object",
          "additionalProperties": {
            "type": "array",
            "items": true
          }
        }
      },
      "additionalProperties": false
    },
    "Projection": {
      "description": "A projection representation that allows projections to be specified either as a simple JSON Pointer, or as an object with separate properties for `loction` and `partition`.",
      "anyOf": [
        {
          "$ref": "#/definitions/JsonPointer"
        },
        {
          "$ref": "#/definitions/FullProjection"
        }
      ]
    },
    "Projections": {
      "description": "Projections are named locations within a collection document which may be used for logical partitioning or directly exposed to databases into which collections are materialized.",
      "examples": [
        {
          "a_field": "/json/ptr",
          "a_partition": {
            "location": "/json/ptr",
            "partition": true
          }
        }
      ],
      "type": "object",
      "additionalProperties": {
        "$ref": "#/definitions/Projection"
      }
    },
    "Register": {
      "description": "Registers are the internal states of a derivation, which can be read and updated by all of its transformations. They're an important building block for joins, aggregations, and other complex stateful workflows.\n\nRegisters are implemented using JSON-Schemas, often ones with reduction annotations. When reading source documents, every distinct shuffle key by which the source collection is read is mapped to a corresponding register value (or, if no shuffle key is defined, the source collection's key is used instead).\n\nThen, an \"update\" lambda of the transformation produces updates which are reduced into the register, and a \"publish\" lambda reads the current (and previous, if updated) register value.",
      "type": "object",
      "required": [
        "schema"
      ],
      "properties": {
        "initial": {
          "title": "Initial value of a keyed register which has never been updated.",
          "description": "If not specified, the default is \"null\".",
          "default": null
        },
        "schema": {
          "title": "Schema which validates and reduces register documents.",
          "allOf": [
            {
              "$ref": "#/definitions/Schema"
            }
          ]
        }
      },
      "additionalProperties": false
    },
    "RelativeUrl": {
      "description": "A URL identifying a resource, which may be a relative local path with respect to the current resource (i.e, ../path/to/flow.yaml), or may be an external absolute URL (i.e., http://example/flow.yaml).",
      "examples": [
        "../path/to/local.yaml",
        "https://example/resource"
      ],
      "type": "string"
    },
    "Schema": {
      "description": "A schema is a draft 2019-09 JSON Schema which validates Flow documents. Schemas also provide annotations at document locations, such as reduction strategies for combining one document into another.\n\nSchemas may be defined inline to the catalog, or given as a relative or absolute URI. URIs may optionally include a JSON fragment pointer that locates a specific sub-schema therein.\n\nI.e, \"schemas/marketing.yaml#/$defs/campaign\" would reference the schema at location {\"$defs\": {\"campaign\": ...}} within ./schemas/marketing.yaml.",
      "examples": [
        "http://example/schema#/$defs/subPath",
        "../path/to/schema#/$defs/subPath",
        {
          "properties": {
            "bar": {
              "const": 42
            },
            "foo": {
              "type": "integer"
            }
          },
          "type": "object"
        },
        {
          "properties": {
            "foo_count": {
              "reduce": {
                "strategy": "sum"
              },
              "type": "integer"
            }
          },
          "reduce": {
            "strategy": "merge"
          },
          "type": "object"
        }
      ],
      "anyOf": [
        {
          "$ref": "#/definitions/RelativeUrl"
        },
        {
          "type": "object",
          "additionalProperties": true
        },
        {
          "type": "boolean"
        }
      ]
    },
    "Source": {
      "examples": [
        {
          "name": "a/collection",
          "partitions": null,
          "schema": null
        }
      ],
      "type": "object",
      "required": [
        "name"
      ],
      "properties": {
        "name": {
          "title": "Name of the collection to be read.",
          "allOf": [
            {
              "$ref": "#/definitions/CollectionName"
            }
          ]
        },
        "partitions": {
          "title": "Selector over partition of the source collection to read.",
          "default": {
            "exclude": {
              "other_partition": [
                32,
                64
              ]
            },
            "include": {
              "a_partition": [
                "A",
                "B"
              ]
            }
          },
          "anyOf": [
            {
              "$ref": "#/definitions/PartitionSelector"
            },
            {
              "type": "null"
            }
          ]
        },
        "schema": {
          "title": "Optional JSON-Schema to validate against the source collection.",
          "description": "All data in the source collection is already validated against the schema of that collection, so providing a source schema is only used for _additional_ validation beyond that.\n\nThis is useful in building \"Extract Load Transform\" patterns, where a collection is captured with minimal schema applied (perhaps because it comes from an uncontrolled third party), and is then progressively verified as collections are derived. If None, the principal schema of the collection is used instead.",
          "default": "../path/to/schema#/$defs/subPath",
          "anyOf": [
            {
              "$ref": "#/definitions/Schema"
            },
            {
              "type": "null"
            }
          ]
        }
      },
      "additionalProperties": false
    },
    "SqlTargetConnection": {
      "type": "object",
      "required": [
        "table",
        "uri"
      ],
      "properties": {
        "table": {
          "description": "The name of the table to materialize into.",
          "type": "string"
        },
        "uri": {
          "description": "The connection URI for the target database, e.g. `postgresql://user:password@my-postgres.test:5432/my_database`",
          "type": "string"
        }
      }
    },
    "TestStep": {
      "examples": [
        {
          "ingest": {
            "collection": "a/collection",
            "documents": [
              {
                "example": "document"
              },
              {
                "another": "document"
              }
            ]
          }
        },
        {
          "verify": {
            "collection": "a/collection",
            "documents": [
              {
                "expected": "document"
              }
            ],
            "partitions": null
          }
        }
      ],
      "anyOf": [
        {
          "description": "Ingest document fixtures into a collection.",
          "type": "object",
          "required": [
            "ingest"
          ],
          "properties": {
            "ingest": {
              "$ref": "#/definitions/TestStepIngest"
            }
          }
        },
        {
          "description": "Verify the contents of a collection match a set of document fixtures.",
          "type": "object",
          "required": [
            "verify"
          ],
          "properties": {
            "verify": {
              "$ref": "#/definitions/TestStepVerify"
            }
          }
        }
      ]
    },
    "TestStepIngest": {
      "description": "An ingestion test step ingests document fixtures into the named collection.",
      "examples": [
        {
          "collection": "a/collection",
          "documents": [
            {
              "example": "document"
            },
            {
              "another": "document"
            }
          ]
        }
      ],
      "type": "object",
      "required": [
        "collection",
        "documents"
      ],
      "properties": {
        "collection": {
          "title": "Name of the collection into which the test will ingest.",
          "allOf": [
            {
              "$ref": "#/definitions/CollectionName"
            }
          ]
        },
        "documents": {
          "title": "Documents to ingest.",
          "description": "Each document must conform to the collection's schema.",
          "type": "array",
          "items": true
        }
      }
    },
    "TestStepVerify": {
      "description": "A verification test step verifies that the contents of the named collection match the expected fixtures, after fully processing all preceding ingestion test steps.",
      "examples": [
        {
          "collection": "a/collection",
          "documents": [
            {
              "expected": "document"
            }
          ],
          "partitions": null
        }
      ],
      "type": "object",
      "required": [
        "collection",
        "documents"
      ],
      "properties": {
        "collection": {
          "title": "Collection into which the test will ingest.",
          "allOf": [
            {
              "$ref": "#/definitions/CollectionName"
            }
          ]
        },
        "documents": {
          "title": "Documents to verify.",
          "description": "Each document may contain only a portion of the matched document's properties, and any properties present in the actual document but not in this document fixture are ignored. All other values must match or the test will fail.",
          "type": "array",
          "items": true
        },
        "partitions": {
          "title": "Selector over partitions to verify.",
          "default": {
            "exclude": {
              "other_partition": [
                32,
                64
              ]
            },
            "include": {
              "a_partition": [
                "A",
                "B"
              ]
            }
          },
          "anyOf": [
            {
              "$ref": "#/definitions/PartitionSelector"
            },
            {
              "type": "null"
            }
          ]
        }
      }
    },
    "Transform": {
      "description": "A Transform reads and shuffles documents of a source collection, and processes each document through either one or both of a register \"update\" lambda and a derived document \"publish\" lambda.",
      "examples": [
        {
          "publish": {
            "nodeJS": "return doPublish(source, register);"
          },
          "readDelay": null,
          "shuffle": null,
          "source": {
            "name": "a/collection",
            "partitions": null,
            "schema": null
          },
          "update": {
            "nodeJS": "return doUpdate(source);"
          }
        }
      ],
      "type": "object",
      "required": [
        "source"
      ],
      "properties": {
        "publish": {
          "title": "Publish lambda that produces documents to publish into the collection.",
          "default": {
            "nodeJS": "return doPublish(source, register);"
          },
          "anyOf": [
            {
              "$ref": "#/definitions/Lambda"
            },
            {
              "type": "null"
            }
          ]
        },
        "readDelay": {
          "title": "Delay applied to documents read by this transform.",
          "description": "Delays are applied as an adjustment to the UUID clock encoded within each document, which is then used to impose a relative ordering of all documents read by this derivation. This means that read delays are applied in a consistent way, even when back-filling over historical documents. When caught up and tailing the source collection, delays also \"gate\" documents such that they aren't processed until the current wall-time reflects the delay.",
          "default": null,
          "type": [
            "string",
            "null"
          ],
          "pattern": "^\\d+(s|m|h)$"
        },
        "shuffle": {
          "title": "Shuffle key by which source documents are mapped to registers.",
          "description": "If empty, the key of the source collection is used.",
          "default": [
            "/json/ptr"
          ],
          "anyOf": [
            {
              "$ref": "#/definitions/CompositeKey"
            },
            {
              "type": "null"
            }
          ]
        },
        "source": {
          "title": "Source collection read by this transform.",
          "allOf": [
            {
              "$ref": "#/definitions/Source"
            }
          ]
        },
        "update": {
          "title": "Update lambda that produces register updates from source documents.",
          "default": {
            "nodeJS": "return doUpdate(source);"
          },
          "anyOf": [
            {
              "$ref": "#/definitions/Lambda"
            },
            {
              "type": "null"
            }
          ]
        }
      },
      "additionalProperties": false
    }
  }
}