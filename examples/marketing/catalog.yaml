nodeDependencies:
  moment: "^2.24"

collections:

  - name: marketing/campaigns
    schema: schemas.yaml#/$defs/campaign
    key: [/campaign_id]
    fixtures: [fixtures/campaigns.yaml]

  - name: marketing/offer/views
    schema: schemas.yaml#/$defs/view
    key: [/view_id]
    fixtures: [fixtures/offer-views.yaml]

  - name: marketing/offer/clicks
    schema: schemas.yaml#/$defs/click
    key: [/click_id]
    fixtures: [fixtures/offer-clicks.yaml]

  - name: marketing/purchases
    schema: schemas.yaml#/$defs/purchase
    key: [/purchase_id]
    fixtures: [fixtures/purchases.yaml]

  - name: marketing/views-with-campaign
    schema: schemas.yaml#/$defs/view-with-campaign
    key: [/view_id]
    fixtures: [fixtures/views-with-campaign.yaml]

    derivation:
      parallelism: 8
      transform:
        # Index the campaign on its id. We broadcast out to 4 processors because
        # there are relatively few of these, and we can spread out the load of any
        # particularly "hot" campaign IDs.
        - source:
            name: marketing/campaigns
          shuffle:
            # As we don't specify a key, the source key "/campaign_id" is used by default.
            broadcast: 4
          lambda:
            nodeJS: |
              await store.set(`${source.campaign_id}`, source)
        # Enrich each view event by joining with its present campaign.
        - source:
            name: marketing/offer/views
          shuffle:
            # Shuffle to a processor which indexed this view's campaign.
            # "choose: 4" will randomly select one of the 4 processors to which
            # this campaign was broadcast.
            key: [/campaign_id]
            choose: 4
          lambda:
            # Join the view with a previously indexed campaign.
            nodeJS: |
              return [{ ...source, campaign: await store.get(`${source.campaign_id}`) }]

  - name: marketing/clicks-with-views
    schema: schemas.yaml#/$defs/click-with-view
    key: [/click_id]
    fixtures: [fixtures/clicks-with-views.yaml]

    derivation:
      parallelism: 8
      transform:
        # Index each view with a 2-day TTL relative to the view's timestamp.
        - source:
            name: marketing/views-with-campaign
          lambda:
            nodeJS: |
              let ts = moment.utc(source.timestamp);
              let expiry = ts.add({days: 2});
              await store.set(source.view_id, source, expiry.toDate());
        # Enrich clicks by adding its indexed `view`.
        - source:
            name: marketing/offer/clicks
          shuffle:
            key: [/view_id]
          lambda:
            nodeJS: |
              return [{ ...source, view: await store.get(source.view_id) }]

  - name: marketing/purchases-with-offers
    # Example of using inline schemas, which can reference external schemas.
    schema:
      description: Purchase event joined with prior offer views and clicks.
      $ref: "schemas.yaml#/$defs/purchase"
      properties:
        views:
          type: array
          items:
            $ref: "schemas.yaml#/$defs/view-with-campaign"
        clicks:
          type: array
          items:
            $ref: "schemas.yaml#/$defs/click-with-view"
      required: [views, clicks]
    key: [/purchase_id]
    fixtures: [fixtures/purchases-with-offers.yaml]

    derivation:
      parallelism: 8

      transform:
        # Index views with a 30-day look-back. For a given user ID, only the first
        # view of any UTC day is indexed (meaning each user will have at most 30
        # views indexed at a given time).
        - source:
            name: marketing/views-with-campaign
          shuffle:
            key: [/user_id]
          lambda:
            nodeJS: |
              let ts = moment.utc(source.timestamp);
              let key = `${source.user_id}/views/${ts.format('YYYY-MM-DD')}`;
              let expiry = ts.add({days: 30});
              await store.set(key, source, expiry.toDate());

        # Index clicks with a 30-day look-back. Track only the first click of a given
        # user and hour. Each click has already been enriched with a joined view.
        - source:
            name: marketing/clicks-with-views
          shuffle:
            key: [/user_id]
          lambda:
            nodeJS: |
              let ts = moment.utc(source.timestamp);
              let key = `${source.user_id}/clicks/${ts.format('yyyy-mm-dd-hh')}`;
              let expiry = ts.add({days: 30});
              await store.set(key, source, expiry.toDate());

        # Enrich purchase events by joining with all indexed views and clicks.
        - source:
            name: marketing/purchases
          shuffle:
            key: [/user_id]
          lambda:
            nodeJS: |
              return [{ ...source,
                views: await store.get(`${source.user_id}/views/`),
                clicks: await store.get(`${source.user_id}/clicks/`),
              }]
