collections:

  - name: marketing/campaigns
    schema: schemas.yaml#/$defs/campaign
    key: [/campaign_id]
    fixtures: [fixtures/campaigns.yaml]

  - name: marketing/offer/views
    schema: schemas.yaml#/$defs/view
    key: [/view_id]
    fixtures: [fixtures/offer-views.yaml]

  - name: marketing/offer/clicks
    schema: schemas.yaml#/$defs/click
    key: [/click_id]
    fixtures: [fixtures/offer-clicks.yaml]

  - name: marketing/purchases
    schema: schemas.yaml#/$defs/purchase
    key: [/purchase_id]
    fixtures: [fixtures/purchases.yaml]

  - name: marketing/views-with-campaign
    schema: schemas.yaml#/$defs/view-with-campaign
    key: [/view_id]
    fixtures: [fixtures/views-with-campaign.yaml]

    derivation:
      parallelism: 8
      transform:
        # Index the campaign on its id. We broadcast out to 4 processors because
        # there are relatively few of these, and we can spread out the load of any
        # particularly "hot" campaign IDs.
        - source: marketing/campaigns
          shuffle:
            # As we don't specify a key, the source key "/campaign_id" is used by default.
            broadcast: 4
          lambda:
            nodeJS: (doc, state) => ctx.setKey(doc.campaign_id, doc)
        # Enrich each view event by joining with its present campaign.
        - source: marketing/offer/views
          shuffle:
            # Shuffle to a processor which indexed this view's campaign.
            # "choose: 4" will randomly select one of the 4 processors to which
            # this campaign was broadcast.
            key: [/campaign_id]
            choose: 4
          lambda:
            # Join the view with a previously indexed campaign.
            nodeJS: |
              (doc, state) => async [
                {..doc, campaign: await state.getKey(doc.campaign_id)},
              ]

  - name: marketing/clicks-with-views
    schema: schemas.yaml#/$defs/click-with-view
    key: [/click_id]
    fixtures: [fixtures/clicks-with-views.yaml]

    derivation:
      parallelism: 8
      transform:
        # Index each view with a 2-day TTL relative to the view's timestamp.
        - source: marketing/views-with-campaign
          lambda:
            nodeJS: |
              with $ts as .timestamp | fromdate |
              with $expiry as $ts + 172800 |
              upsert_key_with_expiry(.view_id; $expiry ; . )
        # Enrich clicks by adding its indexed `view`.
        - source: marketing/offer/clicks
          shuffle:
            key: [/view_id]
          lambda:
            nodeJS: |
              . + {view: load_key(.view_id)}

  - name: marketing/purchases-with-offers
    schema: schemas.yaml#/$defs/purchase-with-offers
    key: [/purchase_id]
    fixtures: [fixtures/purchases-with-offers.yaml]

    derivation:
      parallelism: 8

      transform:
        # Index views with a 30-day look-back. For a given user ID, only the first
        # view of any UTC day is indexed (meaning each user will have at most 30
        # views indexed at a given time).
        - source: marketing/views-with-campaign
          shuffle:
            key: [/user_id]
          lambda:
            nodeJS: |
              let ts = Date.parse(rec.timestamp);
              let ts_day = ts - (ts % 86400000);
              let key = `${rec.user_id}/views/${ts_day}`;
              let expiry = ts + 2592000000;
              insert_key_with_expiry(key, expiry)
        # Index clicks with a 30-day look-back. Track only the first click of a given
        # user and hour. Each click has already been enriched with a joined view.
        - source: marketing/clicks-with-views
          shuffle:
            key: [/user_id]
          lambda:
            nodeJS: |
              with $ts as (.timestamp | fromdate) |
              with $ts_hour as $ts - ($ts % 3600) |
              with $key as "\(.user_id)/clicks/\($ts_hour)";
              with $expiry as $ts + 2592000  |
              insert_key_with_expiry(store_key_with_expiry(
                insert_key_with_expiry($key; $expiry; . )
        # Enrich purchase events by joining with all indexed views and clicks.
        - source: marketing/purchases
          shuffle:
            key: [/user_id]
          lambda:
            nodeJS: |
              (doc, state) => async [{ ..doc,
                  views: await state.getPrefix(`{doc.user_id}/views/`),
                  clicks: await state.getPrefix(`{rec.user_id}/clicks/`),
              }]